#!/usr/bin/python

#
# looptool.py - manipulate files generated by the LoopProf Pin tool
#
# Options:
#
#  -t, -threshold=<value> Filter loops that account for less than <value>
#                         percentage of total execution (default: 0.0)
#
#  -s, -sortby=<param>  addr: address
#                       total: inclusive instructions (default)
#                       self: exclusive instructions
#
# examples:
#  $ looptool.py -t1.0 -sself myprog.loopprof
#

import glob
from optparse import OptionParser
import os
import string
import sys

######################### Config Variables ####################################

Threshold = 0.0
Sortby = 'total'
HumanReadable = True

######################### Utility Functions ###################################

def Fail(cond, str):
    if( cond ):
        print 'error: ' + str
        sys.exit(-1)

def humanReadableNumber(n):
    global HumanReadable
    if( not HumanReadable ):
        return str(n)
    
    if( n < 1000 ):
        return str(n)
    elif( n < 1000000 ):
        return str(n/1000) + 'K'
    elif( n < 1000000000 ):
        return str(n/1000000) + 'M'
    elif( n < 1000000000000 ):
        return str(n/1000000000) + 'G'
    elif( n < 1000000000000000 ):
        return str(n/1000000000000) + 'T'
    
######################### Class Function ######################################

class Function:
    def __init__(self, s, profile):
        items = s.strip().split(',')
        Fail(len(items) != 6, "invalid file format")
        self.addr = string.atoi(items[1], 16)
        self.name = items[2]
        self.calls = int(items[3])
        self.selfIns = int(items[4])
        self.totalIns = int(items[5])
        self.childFunctions = {}
        self.childLoops = {}
        self.parentFunctions = {}
        self.parentLoops = {}
        self.profile = profile
        self.id = profile.idCounter
        profile.idCounter += 1
        self.aboveThreshold = True        

    def addEdges(self, fns, loops):
        for f in fns:
            self.childFunctions[f.addr] = f
                
        for l in loops:
            self.childLoops[l.addr] = l

    def __str__(self):
        calls = humanReadableNumber(self.calls)
        selfIns = humanReadableNumber(self.selfIns)
        totalIns = humanReadableNumber(self.totalIns)
        s = 'function: 0x%016x %s\n'%(self.addr, self.name)
        s += '%16s %16s %16s\n'%('Calls', 'SelfIns', 'TotalIns')
        s += '%16s %16s %16s\n'%(calls, selfIns, totalIns)
        return s

    def graphStr(self):
        pct = self.totalIns * 100. / self.profile.totalIns
        pct = '%2.0f'%pct
        return pct + ' ' + self.name + '()'

    def __cmp__(self, loop):
        global Sortby
        if( Sortby == 'addr' ):
            if( self.addr < loop.addr ):
                return -1
            elif( self.addr > loop.addr ):
                return 1
            else:
                return 0
        if( Sortby == 'self' ):
            if( self.selfIns < loop.selfIns ):
                return -1
            elif( self.selfIns > loop.selfIns ):
                return 1
            else:
                return 0
        if( Sortby == 'total' ):
            if( self.totalIns < loop.totalIns ):
                return -1
            elif( self.totalIns > loop.totalIns ):
                return 1
            else:
                return 0    

######################### Class Loop ##########################################
        
class Loop:
    def __init__(self, s, profile):
        items = s.strip().split(',')
        Fail(len(items) != 19, "invalid file format")
        self.addr = string.atoi(items[1], 16)
        self.srcfile = items[2]
        self.lineno = int(items[3])
        self.iterations = int(items[4])
        self.selfIns = int(items[5])
        self.totalIns = int(items[6])
        self.iterationsHisto = []
        for ih in items[7:]:
            self.iterationsHisto.append(int(ih))
        self.childFunctions = {}
        self.childLoops = {}
        self.parentFunctions = {}
        self.parentLoops = {}
        self.profile = profile
        self.id = profile.idCounter
        profile.idCounter += 1
        self.aboveThreshold = True

    def addEdges(self, fns, loops):
        for f in fns:
            self.childFunctions[f.addr] = f
                
        for l in loops:
            self.childLoops[l.addr] = l

    def __str__(self):
        iterations = humanReadableNumber(self.iterations)
        selfIns = humanReadableNumber(self.selfIns)
        totalIns = humanReadableNumber(self.totalIns)
        
        s = 'loop: 0x%016x %s:%d\n'%(self.addr, self.srcfile, self.lineno)
        s += '%16s %16s %16s\n'%('Iterations', 'SelfIns', 'TotalIns')
        s += '%16s %16s %16s\n'%(iterations, selfIns, totalIns)
        return s

    def graphStr(self):
        pct = self.totalIns * 100. / self.profile.totalIns
        pct = '%2.0f'%pct        
        return(pct + ' ' + os.path.basename(self.srcfile) + ':'
               + str(self.lineno))

    def __cmp__(self, loop):
        global Sortby
        if( Sortby == 'addr' ):
            if( self.addr < loop.addr ):
                return -1
            elif( self.addr > loop.addr ):
                return 1
            else:
                return 0
        if( Sortby == 'self' ):
            if( self.selfIns < loop.selfIns ):
                return -1
            elif( self.selfIns > loop.selfIns ):
                return 1
            else:
                return 0
        if( Sortby == 'total' ):
            if( self.totalIns < loop.totalIns ):
                return -1
            elif( self.totalIns > loop.totalIns ):
                return 1
            else:
                return 0            
        
######################### Class Profile #######################################

class Profile:
    def __init__(self, filename):
        self.Functions = {}
        self.Loops = {}
        self.idCounter = 0
        
        file = open(filename)
        self.filename = filename
        mode = ''
        line = file.readline()
        while( line != '' ):
            if( line[0] == '#' ):
                line = file.readline()
                continue
            
            if( line[0] == 'p' ):
                self.programName = line.strip().split(',')[1]
            elif( line[0] == 'm' ):
                mode = line.strip().split(',')[1]
            elif( mode == 'flat' ):
                if( line[0] == 'l' ):
                    loop = Loop(line, self)
                    self.idCounter += 1
                    self.Loops[loop.addr] = loop
                elif( line[0] == 'f' ):
                    func = Function(line, self)
                    self.idCounter += 1
                    self.Functions[func.addr] = func
                else:
                    Fail(1, "invalid file format")
            elif( mode == 'graph' ):
                if( line[0] != 'l' and line[0] != 'f' ):
                    Fail(1, "invalid file format")
                items = line.strip().split(',')[1:]
                addr = string.atoi(items[0], 16)

                fnAddrs = items[2:items.index('l')]
                loopAddrs = items[items.index('l') + 1:]
                fns = []
                loops = []
                
                for a in map(lambda x: string.atoi(x, 16), fnAddrs):
                    if( self.Functions.has_key(a) ):
                        fns.append(self.Functions[a])
                for a in map(lambda x: string.atoi(x, 16), loopAddrs):
                    if( self.Loops.has_key(a) ):
                        loops.append(self.Loops[a])
                
                if( line[0] == 'l' and self.Loops.has_key(addr)):
                    self.Loops[addr].addEdges(fns, loops)
                elif( line[0] == 'f' and self.Functions.has_key(addr)):
                    self.Functions[addr].addEdges(fns, loops)

            line = file.readline()
        file.close()
        self.totalIns = self.Functions[0].totalIns
        self.insThreshold = self.totalIns * Threshold

        for f in self.Functions.values():
            if( f.totalIns < self.insThreshold ):
                f.aboveThreshold = False

        for l in self.Loops.values():
            if( l.totalIns < self.insThreshold ):
                l.aboveThreshold = False                

    def printFlatFile(self):
        flatFile = open(self.filename[0:-4] + '.loops', 'w')

        lvals = self.Loops.values()
        lvals.sort()
        for l in lvals:
            if( not l.aboveThreshold ): continue
            flatFile.write(str(l))
            flatFile.write('-'*79 + '\n')

        fvals = self.Functions.values()
        fvals.sort()
        for f in fvals:
            if( not f.aboveThreshold ): continue            
            flatFile.write(str(f))
            flatFile.write('-'*79 + '\n')
        flatFile.close()

    def printGrFile(self):
        grFile = open(self.filename[0:-4] + '.gr', 'w')

        grFile.write('// dvc loop graph\n')
        grFile.write('[types]\n')
        grFile.write('2 \"Edge Type\"\n')
        grFile.write('1 \"Node Type\"\n')
        grFile.write('[nodes]\n')

        edges = []
        
        for f in self.Functions.values():
            if( f.addr == 0 ): continue #leave "root" off the graph
            if( not f.aboveThreshold ): continue
            grFile.write(str(f.id) + ' \"' + f.graphStr()
                         + '\"' + ' 1 0 0 256 0\n')
            for c in f.childFunctions.values():
                if( not c.aboveThreshold ): continue
                edges.append((f.id, c.id))

            for c in f.childLoops.values():
                if( not c.aboveThreshold ): continue
                edges.append((f.id, c.id))

        for l in self.Loops.values():
            if( not l.aboveThreshold ): continue
            grFile.write(str(l.id) + ' \"' + l.graphStr()
                         + '\"' + ' 1 0 0 256 0\n')
            for c in l.childFunctions.values():
                if( not c.aboveThreshold ): continue
                edges.append((l.id, c.id))

            for c in l.childLoops.values():
                if( not c.aboveThreshold ): continue
                edges.append((l.id, c.id))          

        grFile.write('[edges]\n')
        for e in edges:
            grFile.write(str(e[0]) + ' ' + str(e[1])
                         + ' \"\"' + ' 2 6 0 0\n')
        grFile.close()

######################### main ################################################

def main(argv):
    parser = OptionParser(usage = "usage: %prog [options] <loopprof output>")

    parser.add_option('-t', '--threshold',
                      dest='threshold',
                      help=('Filter loops that account for less than <value>'
                            ' percentage of total execution (default: 0.00)'),
                      metavar='<percentage>',
                      default='0.00')

    parser.add_option('-s', '--sortby',
                      dest='sortby',
                      help='sort by address, self, or total (default)',
                      metavar='<method>',
                      default='total')

    (options, args) = parser.parse_args()

    if( len(args) != 1 ):
        parser.print_help()
        return -1

    global Threshold
    global Sortby
    Threshold = float(options.threshold)/100.
    Sortby = options.sortby

    if( Sortby != "addr" and Sortby != "self" and Sortby != "total" ):
        Fail(1, Sortby + ": invalid argument to --sortby")

    if( os.path.isdir(args[0]) ):
        for f in glob.glob(args[0] + '/*.raw'):
            p = Profile(f)
            p.printFlatFile()
            p.printGrFile()
    elif( os.path.isfile(args[0]) ):
        p = Profile(args[0])
        p.printFlatFile()
        p.printGrFile()
    else:
        print 'invalid file: ' + args[0]        

if __name__ == "__main__":
    sys.exit(main(sys.argv))
